#/*##########################################################################
# Copyright (C) 2014 European Synchrotron Radiation Facility
#
# This file is part of the PyMca X-ray Fluorescence Toolkit developed at
# the ESRF by the Software group.
#
# This toolkit is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the Free
# Software Foundation; either version 2 of the License, or (at your option)
# any later version.
#
# PyMca is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# PyMca; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
# PyMca follows the dual licensing model of Riverbank's PyQt and cannot be
# used as a free plugin for a non-free program.
#
# Please contact the ESRF industrial unit (industry@esrf.fr) if this license
# is a problem for you.
#
# Author 06/11/2014 T. Rueter (ESRF Data Analysis Unit)
#                   first prototype
# Update 03/06/2015 R. Wilcke (wilcke@esrf.fr)
#                   added code for "Exit" command in "File" menu.
#############################################################################*/
__author__ = "ESRF Data Analysis Unit"

#
# GUI IMPORTS:
# uic: allows processing of ui files
# qt: PyMca version of qt
#
import sys
from PyQt4 import uic
from PyMca5.PyMcaGui import PyMcaQt as qt

#
# IMPORTS FROM RixsTool
#
from .widgets.Models import ProjectModel
from .Items import SpecItem, ScanItem, ImageItem
from .ItemContainer import ItemContainer
from .UiPaths import UiPaths

import numpy
import platform
from cStringIO import StringIO
# from os import linesep as OsLineSep
from os.path import splitext as OsPathSplitExt

import logging
logger = logging.getLogger("mainwindow")

DEBUG = 0
PLATFORM = platform.system()
NEWLINE = '\n'  # instead of OsLineSep


class RIXSMainWindow(qt.QMainWindow):
    def __init__(self, parent=None):
        qt.QMainWindow.__init__(self, parent)

        uiFilePath = UiPaths.mainWindowUiPath()
        uic.loadUi(uiFilePath, self)

        self.setWindowTitle('RixsTool')
        self.setWindowIcon(qt.QIcon("RixsTool/icons/rixs.ico"))

        # TODO: Move this connect to RixsMaskImageWidget
        self.imageView.sigMaskImageWidgetSignal.connect(
            self.handleMaskImageSignal)

        #
        # Connect all the actions generated by the ui file. This mainly concerns
        # the apps menu bar.
        # New actions can be registered in the functions body.
        #
        self.connectActions()

        # TODO: Do I really need more than one project at a time?
        # This is currently unused anyway...
        self.projectDict = {
            '<current>': None,
            '<default>': ProjectModel()
        }
        self.currentProject = self.setCurrentProject()

        #
        # Handle data that enters the data visualization from the project
        # visualization.
        #
        self.projectBrowser.showSignal.connect(self._handleShowSignal)
        self.projectBrowser.removeSignal.connect(self._handleRemoveSignal)

        #
        # SIGNALS
        # Tool windows from RixsTool allow interaction with the displayed data.
        # They can be divided into two types: inplace calculations with the
        # result being immediately displayed and export tools that take data
        # present in the visualization and inject it into the current project.
        #
        # The signals of the latter must therefore trigger this injection
        # process, while signals of the former are handled internally by the
        # RixsMaskImageWidget.
        #

        #
        # INTEGRATION
        #
        self.imageView.sumImageTool.exportCurrentSignal.connect(
            self.exportCurrentImage)
        self.imageView.sumImageTool.exportSelectedSignal.connect(
            self.exportSelectedImage)

        #
        # ENERGY SCALE
        #
        self.imageView.energyScaleTool.energyScaleSignal.connect(
            self.setEnergyScale)

    def setEnergyScale(self):
        scale = self.imageView.energyScaleTool.energyScale()
        logger.debug('RIXSMainWindow.setEnergyScale -- scale: %s' % str(scale))

    def exportSelectedImage(self):
        # items = self.projectBrowser.selectedItems()
        items = self.projectBrowser.selectedContainers()
        self.exportingImages(items)

    def exportCurrentImage(self):
        # item = self.imageView.currentImageItem
        imageItem = self.imageView.currentImageItem
        if not imageItem:
            return
        try:
            container = self.currentProject[imageItem.key()]
        except KeyError:
            print("RIXSMainWindow.exportCurrentImage -- " \
                "Image not found in project!")
        # if not container:
            return
        self.exportingImages([container])

    def exportingImages(self, itemContainerList):
        # def imageToSpectrum(self, imageItemList):
        logger.debug('ProjectView.exportingImages -- Received %d item' % 
            len(itemContainerList))
        toolList = self.imageView.toolList
        sumImageTool = self.imageView.sumImageTool
        oversamp = 1
        # specContainer = self.currentProject['Spectra']

        for container in filter(ItemContainer.hasItem, itemContainerList):
            if container in self.currentProject:
                item = container.item()
                data = item.array

                logger.debug('ProjectView.exportingImages -- Found it! %s' % 
                    container.label)
                for step in toolList:
                    #
                    # Do processing.
                    # Apply filter and alignment to all images.
                    #
                    if not step.active():
                        continue
                    parameters = step.getValues()
                    data = step.process(data, parameters)
                    if step == self.imageView.imageAlignmentWindow:
                        oversamp = parameters['oversamp']

                #
                # Build new tree item
                #
                if sumImageTool.active():
                    result = sumImageTool.process(data, {})
                    key = item.key()
                    newKey = key.replace('.edf', '.dat')

                    newItem = ScanItem(
                        key=newKey,
                        header=item.header,
                        array=result,
                        fileLocation=''
                    )
                    numpnt = len(result)
                    stop = (numpnt - 1) / oversamp + 1
                    scale = numpy.linspace(1., stop, num=numpnt)
                    newItem.setScale(scale)

                    #newItem = SpecItem(
                    #    key=newKey,
                    #    header=item.header,
                    #    array=result,
                    #    fileLocation=''
                    #)

                    # newContainer = ItemContainer(
                    #    item=newItem,
                    #    parent=specContainer,
                    #    label=None  # is set automatically
                    # )

                    self.currentProject.addItem(newItem)

    def handleMaskImageSignal(self, ddict):
        logger.debug("RIXSMainWindow.handleMaskImageSignal -- ddict: %s" %
            str(ddict))

    def handleToolStateChangedSignal(self, state, tool):
        logger.debug("RIXSMainWindow.handleToolStateChangedSignal -- state: %d"
            % state)
        logger.debug("\t%s" % str(tool))

    def setCurrentProject(self, key='<default>'):
        """
        Changes the project. Function is not used at the moment.
        """
        # project = self.projectDict.get(key, None)
        model = self.projectDict['<default>']
        if not model:
            logger.debug(
                'RIXSMainWindow.setCurrentProject -- project not found')
            return self.projectDict['<default>']
        else:
            model = ProjectModel()
        self.fileBrowser.addSignal.connect(model.addFileInfoList)
        self.projectBrowser.setModel(model)
        self.projectDict[key] = model
        #
        # Set width of the columns in the Project Browser
        #
        self.projectBrowser.setColumnWidth(0,250)
        self.projectBrowser.setColumnWidth(1,100)
        self.projectBrowser.setColumnWidth(2,150)
        return model

    def _handleShowSignal(self, itemList):
        """
        :param list itemList: List of :py:class:`RixsTool.Items.ProjectItem`

        Slot to handle the showSignal emitted by
        :py:class:`RixsTool.Items.ProjectItem`.
        Depending on the item type, the item data are visualized.
        """
        for item in itemList:
            if isinstance(item, ImageItem):
                #
                # Received 2-D data, use imageView
                #
                self.imageView.setImageItem(item)
                logger.debug(
                    'RIXSMainWindow._handleShowSignal -- Received ImageItem')
            elif isinstance(item, ScanItem) or isinstance(item, SpecItem):
                #
                # Received 1-D data, use specView
                #
                if isinstance(item, ScanItem):
                    logger.debug(
                        'RIXSMainWindow._handleShowSignal -- Received ScanItem')
                else:
                    logger.debug(
                        'RIXSMainWindow._handleShowSignal -- Received SpecItem')
                if hasattr(item, 'scale') and item.scale() != None:
                    scale = item.scale()
                else:
                    numberOfPoints = len(item.array)
                    # TODO: Lift numpy dependency here
                    scale = numpy.arange(numberOfPoints)

                self.specView.addCurve(x=scale, y=item.array,
                    legend=item.key(), replace=False, replot=True)

        logger.debug('RIXSMainWindow._handleShowSignal -- Done!')

    def _handleRemoveSignal(self, itemList):
        """
        :param list itemList: List of :py:class:`RixsTool.Items.ProjectItem`

        Slot to handle the removeSignal emitted by
        :py:class:`RixsTool.Items.ProjectItem`.
        Depending on the item type, the item data are removed.
        """
        for item in itemList:
            if isinstance(item, ImageItem):
                #
                # Received 2-D data, use imageView
                #
                #self.imageView.setImageItem(item)
                logger.debug(
                    'RIXSMainWindow._handleRemoveSignal -- Received ImageItem')
            elif isinstance(item, ScanItem) or isinstance(item, SpecItem):
                #
                # Received 1-D data, use specView
                #
                if isinstance(item, ScanItem):
                    logger.debug("RIXSMainWindow._handleRemoveSignal -- "
                        "Received ScanItem")
                else:
                    logger.debug("RIXSMainWindow._handleRemoveSignal -- "
                        "Received SpecItem")
                self.specView.removeCurve(legend=item.key(), replot=True)

        logger.debug('RIXSMainWindow._handleRemoveSignal -- Done!')


    def connectActions(self):
        """
        Routine that connects the actions that can be triggered in the menu bar
        to the proper functions. This should only be done during instantiation.
        """
        actionList = [(self.saveSpectraAction, self.saveSpectra),
                      (self.exitAction, sys.exit),
                      (self.colormapAction, self.imageView.selectColormap),
                      (self.flipAction, self.imageView.flipWidget.show),
                      (self.bandPassFilterAction, self.openBandPassTool),
                      (self.bandPassFilterID32Action,
                          self.openBandPassID32Tool),
                      (self.imageAlignmentAction,
                          self.imageView.imageAlignmentWindow.show),
                      (self.integrationAction,
                          self.imageView.sumImageTool.show),
                      (self.energyScaleAction,
                          self.imageView.energyScaleTool.show),
                      (self.projectBrowserShowAction, self.showProjectView),
                      (self.fileBrowserShowAction, self.showFileView),
                      (self.aboutAction, self.about)
                      ]
        for action, function in actionList:
            action.triggered[()].connect(function)
        logger.debug('All Actions connected..')

    def saveSpectra(self):
        """
        Save routine that writes all spectra of the 'Spectra' node to a text
        file.
        """
        try:
            (fileNameList, singleFile, comment) = RixsSaveSpectraDialog.\
                getSaveFileName(parent=self,
                                caption='Save spectra',
                                directory=str(qt.QDir.current().absolutePath()))
            fileName = fileNameList[0]
        except IndexError:
            # Returned list is empty
            print('RIXSMainWindow.saveSpectra -- IndexError')
            return
        except ValueError:
            print('RIXSMainWindow.saveSpectra -- ValueError')
            # Returned list is empty
            return

        logger.debug('RIXSMainWindow.saveSpectra -- result: %s' %
            str(fileNameList))

        #
        # Loop through all spectra in the top level of 'Spectra' group
        #
        specNode = self.currentProject['Spectra']
        specString = StringIO()

        itemList = [node.item() for node in specNode.children if node.hasItem]
        for idx, item in enumerate(itemList):
            #
            # Determine the data type to be written
            #
            if isinstance(item, ScanItem):
                scale = item.scale()
            elif isinstance(item, SpecItem):
                #
                # SpecItem does not have a scale, generate one by using the
                # length of the array.
                #
                scale = numpy.arange(
                    start=0,
                    stop=len(item.array),
                    dtype=item.array.dtype)
            else:
                raise NotImplementedError("RIXSMainWindow.saveSpectra -- " \
                    "Unknown item type: %s" % type(item))

            # Stack and transpose
            data = numpy.vstack((scale, item.array)).T
            if data.ndim == 1:
                nRows, nCols = data.shape[0], 1
            elif data.ndim == 2:
                nRows, nCols = data.shape
            else:
                raise NotImplementedError("RIXSMainWindow.saveSpectra -- " \
                    "Cannot write item with dimensionality > 2")

            if isinstance(item, SpecItem):
                #
                # Start to write spec file header...
                #
                scanNo = 1
                specString.write(NEWLINE)
                specString.write('#S %d %s' % (scanNo, item.key()) + NEWLINE)
                specString.write('#N %d' % nCols + NEWLINE) # Number of columns
                specString.write('#L PixelNo  Counts' + NEWLINE) # Column labels

                #
                # Write EDF header in #U comments
                #
                # headerLines = item.header.split('\n')
                # # Determine order of magnitude
                # if len(headerLines) > 0 and len(item.header) > 0:
                #    magnitude = len(str(len(headerLines)))
                #    for jdx, line in enumerate(headerLines):
                #    - Format string explanation:
                #    - #U              -> prefix, indicates header in spec file
                #    - {idx:0>{width}} -> write value 'idx' in a string with
                #                         'width' letters, align value of 'idx'
                #                         on the right and fill the remaining
                #                         space with zeros (i.e. leading zeros)
                #    - {line}          -> place value 'line' here
                #
                #    specString.write('#U{idx:0>{width}} {line}'.format(idx=jdx,
                #            width=magnitude, line=line) + NEWLINE)
                #
                # ...finish to write spec file header
                #
                logger.debug("RIXSMainWindow.saveSpectra -- header: " \
                    "type(header): %s\n'%s'" % (type(item.header), item.header))

            #
            # Write data using numpy.savetxt, parameter fname can be file handle
            #
            numpy.savetxt(
                fname=specString,
                X=data,
                fmt='%.6f',
                delimiter=' ',
                newline=NEWLINE
            )

            if isinstance(item, SpecItem):
                specString.write(NEWLINE)

            if not singleFile:
                #
                # File names feature indexation
                #
                path, ext = OsPathSplitExt(fileName)
                numberedPath = '{path}_{idx:0>{width}}{ext}'.format(
                    path=path,
                    idx=idx,
                    width=len(itemList),
                    ext=ext
                )
                with open(numberedPath, 'wb') as fileHandle:
                    fileHandle.write(specString.getvalue())

                #
                # Reset StringIO
                #
                specString = StringIO()

        if singleFile:
            with open(fileName, 'wb') as fileHandle:
                fileHandle.write(specString.getvalue())

        logger.debug('RIXSMainWindow.saveSpectra -- Done!')

    def openBandPassTool(self):
        self.imageView.setCurrentFilter('bandpass')

    def openBandPassID32Tool(self):
        self.imageView.setCurrentFilter('bandpassID32')

    def showProjectView(self):
        self.projectBrowserDock.setVisible(
            self.projectBrowserShowAction.isChecked())

    def showFileView(self):
        self.fileBrowserDock.setVisible(self.fileBrowserShowAction.isChecked())

    def about(self):
        txt = "Software toolkit for the analysis of\n" \
        "Resonant Inelastic X-ray Scattering (RIXS) experiments\n" \
        "as performed at beamline ID32 of the ESRF.\n" \
        "Based on Armando Sole's X-ray fluoresence toolkit PyMCA\n" \
        "(https://github.com/vasole/pymca)."
        qt.QMessageBox.about(self, "RixsTool", txt)


class RixsSaveSpectraDialog(qt.QFileDialog):
    def __init__(self, parent, caption, directory):
        qt.QFileDialog.__init__(self, parent, caption, directory, '')

        saveOptsGB = qt.QGroupBox('Save options', self)
        saveOptsBG = qt.QButtonGroup()
        self.singleFile = qt.QRadioButton(
            'Save spectra in one single file', self)
        self.individualFiles = qt.QRadioButton(
            'Save spectra in individual files', self)
        self.singleFile.setChecked(True)

        saveOptsBG.addButton(self.individualFiles)
        saveOptsBG.addButton(self.singleFile)
        saveOptsBG.setExclusive(True) # Only one button at a time can be checked

        mainLayout = self.layout()
        optsLayout = qt.QGridLayout()
        optsLayout.addWidget(self.individualFiles, 0, 0)
        optsLayout.addWidget(self.singleFile, 1, 0)
        saveOptsGB.setLayout(optsLayout)
        mainLayout.addWidget(saveOptsGB, 4, 0, 1, 3)

    @staticmethod
    def getSaveFileName(parent, caption, directory, typeFilter=None,
        selectedFilter=None, options=None):
        dial = RixsSaveSpectraDialog(parent, caption, directory)
        dial.setAcceptMode(qt.QFileDialog.AcceptSave)
        singleFile = None
        comment = None
        fileNameList = []
        if dial.exec_():
            singleFile = dial.singleFile.isChecked()
            fileNameList = [qt.safe_str(fn) for fn in dial.selectedFiles()]
        return fileNameList, singleFile, comment


class DummyNotifier(qt.QObject):
    def signalReceived(self, val=None):
        print('DummyNotifier.signal received -- kw:\n', str(val))

if __name__ == '__main__':
    app = qt.QApplication([])
    win = RIXSMainWindow()
    win.show()
    app.exec_()
